/* * The MIT License (MIT) *  * Copyright (c) 2016 LE SAUCE Julien *  * Permission is hereby granted, free of charge, to any person obtaining a copy * of this software and associated documentation files (the "Software"), to deal * in the Software without restriction, including without limitation the rights * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell * copies of the Software, and to permit persons to whom the Software is * furnished to do so, subject to the following conditions: *  * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE * SOFTWARE. */package org.jls.toolbox.widget.spinner;import javax.swing.AbstractSpinnerModel;/** * Modèle de données d'un spinner hexadécimal. *  * @author LE SAUCE Julien * @date Feb 24, 2015 */public class HexSpinnerModel extends AbstractSpinnerModel {    private static final long serialVersionUID = -2641539906615254015L;    private long value;    private final long offset;    private long stepSize;    private Long minimum, maximum;    /**     * Permet d'instancier un modèle de données.     *      * @param value     *            Valeur initiale du modèle.     * @param minimum     *            Valeur minimale inclusive.     * @param maximum     *            Valeur maximale inclusive.     * @param stepSize     *            Valeur d'incrément entre deux valeurs consécutives.     */    public HexSpinnerModel(long value, Long minimum, Long maximum, long stepSize) {        if (!((minimum == null || value >= minimum) && (maximum == null || value <= maximum))) {            throw new IllegalArgumentException("(minimum <= value <= maximum) is false");        }        this.value = value;        this.offset = value;        this.minimum = minimum;        this.maximum = maximum;        this.stepSize = stepSize;    }    @Override    public Object getValue () {        return Long.toHexString(this.value).toUpperCase();    }    @Override    public void setValue (Object value) {        long newVal = this.value;        if (value == null) {            return;        } else if (value instanceof String) {            String newString = (String) value;            // Vérification de l'entrée            if (newString.matches("^[0-9a-fA-F]+$")) {                newVal = Long.parseLong(newString, 16);            } else {                throw new IllegalArgumentException("Invalid hexadecimal string : '" + newString + "'");            }        } else if (value instanceof Long) {            newVal = ((Long) value).longValue();        }        // Si la valeur n'est pas autorisée        if (newVal % this.stepSize != 0) {            // On l'arrondi à la valeur autorisée la plus proche            newVal = roundValue(newVal);        }        // Si la nouvelle valeur est supérieure au maximum (null implique pas de        // limite)        if (this.maximum != null && newVal > this.maximum) {            // On sature la valeur            newVal = this.maximum;        }        // Si la nouvelle valeur est inférieure au minimum (null implique pas de        // limite)        if (this.minimum != null && newVal < this.minimum) {            // On sature la valeur            newVal = this.minimum;        }        // Si la nouvelle valeur est différente de la valeur du modèle        if (newVal != this.value) {            // On met à jour le modèle            this.value = newVal;            fireStateChanged();        }    }    @Override    public Object getPreviousValue () {        return Long.toHexString(incrementValue(-1)).toUpperCase();    }    @Override    public Object getNextValue () {        return Long.toHexString(incrementValue(+1)).toUpperCase();    }    /**     * Renvoie la valeur du modèle incrémentée du nombre d'incréments spécifié. Pour     * cela on récupère la valeur du modèle et on l'incrémente du nombre de pas     * spécifié multiplié par le pas d'incrémentation <i>stepSize</i>. On renvoie     * alors cette valeur sans mettre à jour le modèle.     *      * @param inc     *            Nombre de pas d'incrémentation.     * @return Valeur du modèle incrémentée.     */    private long incrementValue (long inc) {        long newValue = this.value + this.stepSize * inc;        // Si la valeur incrémentée est supérieure au maximum        if (this.maximum != null && newValue > this.maximum) {            // On sature la valeur            return this.maximum;        }        // Si la valeur incrémentée est inférieure au minimum        if (this.minimum != null && newValue < this.minimum) {            // On sature la valeur            return this.minimum;        }        // Sinon on renvoie la valeur incrémentée        else {            return newValue;        }    }    /**     * Permet d'arrondir une valeur interdite à la valeur autorisée inférieure en     * tenant compte du gap et de l'offset par rapport à 0.     *      * @param value     *            Valeur à arrondir.     * @return Valeur autorisée la plus proche.     */    private long roundValue (long value) {        long newVal = (value - this.offset) / this.stepSize;        newVal = newVal * this.stepSize + this.offset;        return newVal;    }    /**     * Permet de modifier la valeur minimale que peut prendre la valeur du modèle.     *      * @param min     *            Valeur minimale.     */    public void setMinimum (Long min) {        if (!min.equals(this.minimum)) {            this.minimum = min;            fireStateChanged();        }    }    /**     * Renvoie la valeur minimale que peut prendre la valeur du modèle.     *      * @return Valeur minimale.     */    public Long getMinimum () {        return this.minimum;    }    /**     * Permet de modifier la valeur maximale que peut prendre la valeur du modèle.     *      * @param max     *            Valeur maximale.     */    public void setMaximum (Long max) {        if (!max.equals(this.maximum)) {            this.maximum = max;            fireStateChanged();        }    }    /**     * Renvoie la valeur maximale que peut prendre la valeur du modèle.     *      * @return Valeur maximale.     */    public Long getMaximum () {        return this.maximum;    }    /**     * Permet de modifier le pas d'incrémentation du modèle.     *      * @param step     *            Pas d'incrémentation.     */    public void setStepSize (long step) {        if (step != this.stepSize) {            this.stepSize = step;            fireStateChanged();        }    }    /**     * Renvoie le pas d'incrémentation du modèle.     *      * @return Pas d'incrémentation.     */    public Long getStepSize () {        return this.stepSize;    }    /**     * Renvoie la valeur décimale du modèle.     *      * @return Valeur décimale du modèle.     */    public long getNumber () {        return this.value;    }}